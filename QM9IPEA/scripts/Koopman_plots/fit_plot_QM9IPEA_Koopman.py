# competent_formatting taken from: https://github.com/kvkarandashev/competent_formatting
import json, os
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score
from sortedcontainers import SortedList
from competent_formatting.tables import latex_table, MultiColumn, MultiRow, phantom
from competent_formatting.number_formatting import LaTeXPlainFloat

font = {"size": 10.5}
#        'weight' : 'bold', family' : 'arial'
matplotlib.rc(
    "font",
    **font,
)

method_label_dict = {
    "DFHF": "DF-HF",
    "DFHF+CABS": "DF-HF-CABS",
    "PNO-LCCSD-F12B": "PNO-LCCSD-F12b",
    "PNO-LCCSD(T)-F12B": "PNO-LCCSD(T)-F12b",
    "PNO-LCCSD(T*)-F12B": "PNO-LCCSD(T*)-F12b",
}


def get_method_label(method_name):
    if method_name in method_label_dict:
        return method_label_dict[method_name]
    return method_name


trend_fontsize = 12.5
legend_fontsize = 12.5
axis_fontsize = 12.5
title_fontsize = 12.5

range_space = 0.05

folder = os.environ["DATA"] + "/QM9IPEA"

name = folder + "/QM9IPEA.json"

with open(name, "r") as f:
    data_dict = json.load(f)

methods = list(data_dict["IONIZATION_ENERGY"].keys())

print("Methods:", methods)

IE_lbl = "IE"
EA_lbl = "EA"
HOMO_lbl = r"$E_{\mathrm{HOMO}}$"
LUMO_lbl = r"$E_{\mathrm{LUMO}}$"
LUMO_subset_main_name = "major"
LUMO_subset_other_name = "minor"

au2eV = 27.211598535

full_quant_name = {
    IE_lbl: "IONIZATION_ENERGY",
    EA_lbl: "ELECTRON_AFFINITY",
    HOMO_lbl: "HOMO_ENERGY",
    LUMO_lbl: "LUMO_ENERGY",
}

trend_eq_coords = {
    HOMO_lbl: {
        (0, 0): (-10.5, 13.5),
        (1, 0): (-10.5, 13.5),
        (0, 1): (-10.5, 13.5),
        (1, 1): (-10.5, 13.5),
        (0, 2): (-10.5, 13.5),
        (1, 2): (-10.5, 13.5),
    },
    LUMO_lbl: {
        (0, 0): {True: (0.25, 1.55), False: (-0.75, -0.95)},
        (1, 0): {True: (0.36, 1.8), False: (-0.75, -0.95)},
        (0, 1): {True: (0.36, 1.8), False: (-0.75, -0.95)},
        (1, 1): {True: (0.36, 1.8), False: (-0.75, -0.95)},
        (0, 2): {True: (0.36, 1.8), False: (-0.75, -0.95)},
        (1, 2): {True: (0.36, 1.8), False: (-0.75, -0.95)},
    },
}

# the file is generated by ../sanity_check/koopman_check_wseparation_line.py
special_QM9_ids = SortedList()
with open(r"quant_cut_PNO-LCCSD(T*)-F12B.txt", "r") as f:
    for l in f.readlines():
        special_QM9_ids.add(int(l.split()[5]))


def axis_range(all_values):
    if isinstance(all_values, dict):
        flattened_all_values = []
        for val_list in all_values.values():
            flattened_all_values += val_list
        return axis_range(flattened_all_values)
    min_val = None
    max_val = None
    for val_unscaled in all_values:
        if np.isnan(val_unscaled):
            continue
        val = val_unscaled * au2eV
        if (min_val is None) or (min_val > val):
            min_val = val
        if (max_val is None) or (max_val < val):
            max_val = val

    val_range_magnitude = max_val - min_val
    range_absolute_space = val_range_magnitude * range_space
    return min_val - range_absolute_space, max_val + range_absolute_space


def str_to_raw(s):
    raw_map = {8: r"\b", 7: r"\a", 12: r"\f", 10: r"\n", 13: r"\r", 9: r"\t", 11: r"\v"}
    return r"".join(i if ord(i) > 32 else raw_map.get(ord(i), i) for i in s)


def plot_with(
    quant_orb,
    quant_en,
    method,
    row_id,
    col_id,
    xrange,
    ax,
    marker,
    marker_color,
    ltype,
    legend_extra=None,
    special=None,
):
    xs = []
    ys = []
    for x, y, QM9_id in zip(
        data_dict[full_quant_name[quant_orb]],
        data_dict[full_quant_name[quant_en]][method],
        data_dict["QM9_ID"],
    ):
        if np.isnan(x) or np.isnan(y):
            continue
        if special is not None:
            if special != (QM9_id in special_QM9_ids):
                continue
        xs.append(x * au2eV)
        ys.append(y * au2eV)
    z = np.polyfit(xs, ys, 1)
    p = np.poly1d(z)
    legend_main = f"{quant_orb} vs {quant_en}"
    legend_trendline = "trendline"
    if legend_extra is not None:
        legend_addition = f" ({legend_extra})"
        legend_main += legend_addition
        legend_trendline += legend_addition
    ax.plot(xs, ys, marker, label=legend_main, color=marker_color)
    ax.plot(
        list(xrange),
        p(list(xrange)),
        linestyle=ltype,
        label=legend_trendline,
        color="black",
    )
    R_val = r2_score(ys, p(xs))
    R_eq = r"R^{2}=" + "%.3f" % R_val
    teq_coords = trend_eq_coords[quant_orb][(row_id, col_id)]
    if special is not None:
        teq_coords = teq_coords[special]
    if special is None:
        text_color = "black"
    else:
        text_color = marker_color
    R_eq = r"$\mathbf{" + R_eq + r"}$"
    ax.text(*teq_coords, R_eq, fontsize=trend_fontsize, usetex=True, color=text_color)
    return (*z, R_val)


def plot_corr(
    quant_orb,
    quant_en,
    method,
    ax,
    row_id,
    col_id,
    all_xrange,
    all_yrange,
    check_border=True,
    display_title=True,
    latex_output=None,
):
    if quant_orb == HOMO_lbl:
        slope, intercept, R_eq = plot_with(
            quant_orb,
            quant_en,
            method,
            row_id,
            col_id,
            all_xrange,
            ax,
            "+",
            "blue",
            "dashed",
        )
        if latex_output is not None:
            latex_output.append([get_method_label(method), slope, intercept, R_eq])
    else:
        assert quant_orb == LUMO_lbl
        slope1, intercept1, R_eq1 = plot_with(
            quant_orb,
            quant_en,
            method,
            row_id,
            col_id,
            all_xrange,
            ax,
            "x",
            "blue",
            "dashdot",
            special=False,
            legend_extra=LUMO_subset_main_name,
        )
        slope2, intercept2, R_eq2 = plot_with(
            quant_orb,
            quant_en,
            method,
            row_id,
            col_id,
            all_xrange,
            ax,
            "x",
            "red",
            "dotted",
            special=True,
            legend_extra=LUMO_subset_other_name,
        )
        if latex_output is not None:
            latex_output.append(
                [
                    get_method_label(method),
                    slope1,
                    intercept1,
                    R_eq1,
                    phantom,
                    slope2,
                    intercept2,
                    R_eq2,
                ]
            )
    # the line equation:
    ax.set_xlim(all_xrange)
    ax.set_ylim(all_yrange)
    ax.minorticks_on()
    if (row_id == 1) or (not check_border):
        ax.set_xlabel(xlabel=f"{quant_orb}, eV", fontsize=axis_fontsize)
        ax.ticklabel_format(axis="x", style="plain")
    else:
        ax.set_xlabel(xlabel=None)
        ax.tick_params(labelbottom=False)
    if (col_id == 0) or (not check_border):
        ax.set_ylabel(f"{quant_en}, eV", fontsize=axis_fontsize)
    #    else:
    #        plt.setp(ax.get_yticklabels(),visible = False)
    if display_title:
        ax.set_title(get_method_label(method), fontsize=title_fontsize)
    return ax.get_legend_handles_labels()


w_pads = {HOMO_lbl: 0.25, LUMO_lbl: -0.25}

bbox_to_anchor_vals = {HOMO_lbl: (0.705, 1.04), LUMO_lbl: (0.83, 0.95)}


slope_lbl = "slope"
intercept_lbl = "intercept"
R2_table_lbl = r"$R^{2}$"


def get_latex_output_start(quant_orb):
    if quant_orb == HOMO_lbl:
        return [["method", slope_lbl, intercept_lbl, R2_table_lbl]]
    else:
        assert quant_orb == LUMO_lbl
        return [
            [
                MultiRow("method", 2),
                MultiColumn(LUMO_subset_main_name, 3),
                phantom,
                MultiColumn(LUMO_subset_other_name, 3),
            ],
            [
                None,
                slope_lbl,
                intercept_lbl,
                R2_table_lbl,
                phantom,
                slope_lbl,
                intercept_lbl,
                R2_table_lbl,
            ],
        ]


def print_latex_output(latex_output, quant_orb):
    if quant_orb == HOMO_lbl:
        midrule_pos = 1
        column_types = "lccc"
        cline_positions = ({},)
    else:
        midrule_pos = 2
        column_types = "lccccccc"
        cline_positions = {1: [(2, 4), (6, 8)]}
    latex_output = latex_table(
        latex_output,
        column_types=column_types,
        midrule_positions=[midrule_pos],
        cline_positions=cline_positions,
        float_formatter=LaTeXPlainFloat(3),
    )
    open(f"QM9IPEA_linear_regression_{full_quant_name[quant_orb]}.tex", "w").write(
        latex_output
    )


def plot_all(quant_orb, quant_en):
    fquant_orb = full_quant_name[quant_orb]
    fquant_en = full_quant_name[quant_en]
    all_xrange = axis_range(data_dict[fquant_orb])
    all_yrange = axis_range(data_dict[fquant_en])

    fig, axs = plt.subplots(
        ncols=3,
        nrows=3,
        figsize=(7.5, 6.0),
        sharey=True,
        sharex=False,
        tight_layout=True,
    )

    latex_output = get_latex_output_start(quant_orb)

    method_id = 0
    for row_id in range(2):
        for col_id in range(3):
            method = methods[method_id]
            handles, labels = plot_corr(
                quant_orb,
                quant_en,
                method,
                axs[row_id, col_id],
                row_id,
                col_id,
                all_xrange,
                all_yrange,
                latex_output=latex_output,
            )
            method_id += 1

    print_latex_output(latex_output, quant_orb)

    gs = axs[-1, -1].get_gridspec()

    for method_stack in range(3):
        axs[-1, method_stack].remove()

    legend_space = fig.add_subplot(gs[-1, :])

    legend_space.axis("off")

    legend_space.legend(
        handles,
        labels,
        ncols=2,
        bbox_to_anchor=bbox_to_anchor_vals[quant_orb],
        fontsize=legend_fontsize,
        frameon=False,
    )
    fig.tight_layout(h_pad=0.0, w_pad=w_pads[quant_orb], pad=0.0)

    plt.savefig(
        f"QM9IPEA_Koopman_{fquant_orb}_{fquant_en}.pdf",
        format="pdf",
        bbox_inches="tight",
    )
    plt.clf()


if __name__ == "__main__":
    for corr_pair in [(HOMO_lbl, IE_lbl), (LUMO_lbl, EA_lbl)]:
        plot_all(*corr_pair)
